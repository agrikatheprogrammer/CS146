(BFS) This algorithm is used to perform a level order traversal of a binary tree and return the elements at each level in separate lists. Here's a breakdown of how it works:

Initialization:

Initialize an empty list result to store the lists of elements at each level.
Initialize a queue qe (a LinkedList acting as a queue) to perform breadth-first traversal.
Add the root node to the queue.
Initialize a empty list of integers (to be added to result).
Initialize a variable count to keep track of the number of nodes at the current level.

Traversal:

While there are nodes in the queue (count != 0), do the following:
If the front of the queue (qe.peek()) is not null:
Add the value of the current node (qe.peek().val) to the toadd list.
If the current node has a right child, enqueue it.
If the current node has a left child, enqueue it.
Dequeue the current node.
Decrement count since we have processed one node at this level.
If count becomes zero, it means we have finished processing all nodes at the current level.
Add the toadd list (which contains elements of the current level) to the result list.
Clear toadd to prepare for the next level.
Update count to the size of the queue, which represents the number of nodes at the next level.

Return Result:

Once the traversal is complete, return the result list containing lists of elements' values at each level.
